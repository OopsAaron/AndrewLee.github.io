<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/robot-4291692_1280.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/robot-4291692_1280.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-barber-shop.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>


  <meta name="description" content="BERT论文阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="2020-10-26-BERT论文阅读及详解">
<meta property="og:url" content="http://yoursite.com/2020/10/26/2020-10-26-BERT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8F%8A%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="思建的NLP之旅">
<meta property="og:description" content="BERT论文阅读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="e:/myBlog/source_posts/bert-2.png">
<meta property="og:image" content="e:/myBlog/source_posts/bert-3.png">
<meta property="og:image" content="e:/myBlog/source_posts/image-20201026200944962.png">
<meta property="og:image" content="e:/myBlog/source_posts/v2-0a6e600043f5fac827034bbd97c17e3b_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/v2-baccec0f601c4f84d5b133070cd23925_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/v2-ee790ee9c9843cf405c5a86f874095d0_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/v2-583765858249a8ebf5c0ececea2cd63c_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/v2-9979c95d66a71a720207a48311702430_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/v2-d36db30f3c68a097f32ed0b49f9845cc_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/v2-4f9f62a7776afcdd1e1c99dfa57b965f_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/v2-f576d9d19c9dcac1c6ee6ea28ea7a2d9_720w.jpg">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/equation">
<meta property="og:image" content="e:/myBlog/source_posts/20191019174056699.png">
<meta property="og:image" content="e:/myBlog/source_posts/20191019174247812.png">
<meta property="og:image" content="e:/myBlog/source_posts/20190418105905367.png">
<meta property="og:image" content="e:/myBlog/source_posts/20190418111747424.png">
<meta property="og:image" content="e:/myBlog/source_posts/2019041811190075.png">
<meta property="og:image" content="e:/myBlog/source_posts/20190418112208513.png">
<meta property="og:image" content="e:/myBlog/source_posts/20190418112554368.png">
<meta property="article:published_time" content="2020-10-26T12:05:46.000Z">
<meta property="article:modified_time" content="2020-10-28T12:39:23.136Z">
<meta property="article:author" content="李思建">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/myBlog/source_posts/bert-2.png">

<link rel="canonical" href="http://yoursite.com/2020/10/26/2020-10-26-BERT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8F%8A%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2020-10-26-BERT论文阅读及详解 | 思建的NLP之旅</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>



<link rel="alternate" href="/atom.xml" title="思建的NLP之旅" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>




    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">思建的NLP之旅</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">24</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">67</span></a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fas fa-location-arrow fa-fw"></i>利器</a>

  </li>
        <li class="menu-item menu-item-onesentence">

    <a href="/onesentence" rel="section"><i class="fas fa-bowling-ball fa-fw"></i>一句话</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>大佬</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/OopsAaron" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/26/2020-10-26-BERT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8F%8A%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="李思建">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思建的NLP之旅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2020-10-26-BERT论文阅读及详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-26 20:05:46" itemprop="dateCreated datePublished" datetime="2020-10-26T20:05:46+08:00">2020-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-28 20:39:23" itemprop="dateModified" datetime="2020-10-28T20:39:23+08:00">2020-10-28</time>
              </span>

          
            <span id="/2020/10/26/2020-10-26-BERT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8F%8A%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="2020-10-26-BERT论文阅读及详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/26/2020-10-26-BERT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8F%8A%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/26/2020-10-26-BERT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8F%8A%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 分钟</span>
            </span>
            <div class="post-description">BERT论文阅读</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>BERT是谷歌发布的基于双向 Transformer的大规模预训练语言模型，该预训练模型能高效抽取文本信息并应用于各种NLP任务，并刷新了 11 项 NLP 任务的当前最优性能记录。</p>
<p>BERT的全称是基于Transformer的双向编码器表征，<strong>其中“双向”表示模型在处理某一个词时，它能同时利用前面的词和后面的词两部分信息</strong>。</p>
<p>BERT的本质上是通过在海量的语料的基础上运行自监督学习方法<strong>为单词学习一个好的特征表示</strong>，所谓自监督学习是指在没有人工标注的数据上运行的监督学习。</p>
<p>在以后特定的NLP任务中，<strong>我们可以直接使用BERT的特征表示作为该任务的词嵌入特征。</strong>所以BERT提供的是一个供其它任务迁移学习的模型，该模型可以根据任务微调或者固定之后作为特征提取器。</p>
<hr>
<p>BERT仍然使用的是Transformer模型，它pretraining的不是普通的语言模型，而是Mask语言模型。在介绍Mask语言模型之前我们先介绍BERT的输入表示。</p>
<h3 id="输入表示">输入表示</h3>
<p>BERT的输入表示如图下图所示。比如输入的是两个句子”my dog is cute”，”he likes playing”。后面会解释为什么需要两个句子。这里采用类似GPT的两个句子的表示方法，首先会在第一个句子的开头增加一个特殊的Token [CLS]，在cute的后面增加一个[SEP]表示第一个句子结束，在##ing后面也会增加一个[SEP]。</p>
<p>注意这里的分词会把”playing”分成”play”和”##ing”两个Token，这种把词分成更细粒度的Word Piece的方法在前面的机器翻译部分介绍过了，这是一种解决未登录词的常见办法，后面的代码部分也会简单介绍。</p>
<p>接着对每个Token进行3个Embedding：词的Embedding；位置的Embedding和Segment的Embedding。词的Embedding大家都很熟悉了，而位置的Embedding和词类似，把一个位置(比如2)映射成一个低维稠密的向量。而Segment只有两个，要么是属于第一个句子(segment)要么属于第二个句子，不管那个句子，它都对应一个Embedding向量。同一个句子的Segment Embedding是共享的，这样它能够学习到属于不同Segment的信息。</p>
<blockquote>
<p>对于情感分类这样的任务，只有一个句子，因此Segment id总是0；而对于Entailment任务，输入是两个句子，因此Segment是0或者1。</p>
</blockquote>
<p>BERT模型要求有一个固定的Sequence的长度，比如128。如果不够就在后面padding，否则就截取掉多余的Token，从而保证输入是一个固定长度的Token序列，后面的代码会详细的介绍。第一个Token总是特殊的[CLS]，它本身没有任何语义，因此它会(必须)编码整个句子(其它词)的语义。</p>
<p><img src="E:\myBlog\source_posts\bert-2.png" alt="img"> <em>图：BERT的输入表示</em></p>
<h3 id="mask-lm">Mask LM</h3>
<p>为了解决只能利用单向信息的问题，<strong>BERT使用的是Mask语言模型而不是普通的语言模型</strong>。Mask语言模型有点类似与完形填空——给定一个句子，<strong>把其中某个词遮挡起来，让人猜测可能的词</strong>。这里会随机的Mask掉15%的词，然后让BERT来预测这些Mask的词，通过调整模型的参数使得模型预测正确的概率尽可能大，这等价于交叉熵的损失函数。这样的Transformer在编码一个词的时候会(必须)参考上下文的信息。</p>
<p>但是这有一个问题：<strong>在Pretraining Mask LM时会出现特殊的Token [MASK]，但是在后面的fine-tuning时却不会出现，这会出现Mismatch的问题。</strong></p>
<p>因此BERT中，如果某个Token在被选中的15%个Token里，则按照下面的方式随机的执行：</p>
<ul>
<li><p>80%的概率替换成[MASK]，比如my dog is hairy → my dog is [MASK]</p></li>
<li><p>10%的概率替换成随机的一个词，比如my dog is hairy → my dog is apple</p></li>
<li><p>10%的概率替换成它本身，比如my dog is hairy → my dog is hairy</p></li>
</ul>
<blockquote>
<p>这样做的好处是，BERT并不知道[MASK]替换的是哪一个词，而且任何一个词都有可能是被替换掉的，比如它看到的apple可能是被替换的词。这样<strong>强迫模型在编码当前时刻的时候不能太依赖于当前的词，而要考虑它的上下文，甚至更加上下文进行”纠错”。</strong>比如上面的例子模型在编码apple是根据上下文my dog is应该把apple(部分)编码成hairy的语义而不是apple的语义。</p>
</blockquote>
<h3 id="预测句子关系">预测句子关系</h3>
<p>在有些任务中，比如问答，<strong>前后两个句子有一定的关联关系，我们希望BERT Pretraining的模型能够学习到这种关系。因此BERT还增加了一个新的任务——预测两个句子是否有关联关系</strong>。这是一种Multi-Task Learing。BERT要求的Pretraining的数据是一个一个的”文章”，比如它使用了BookCorpus和维基百科的数据，BookCorpus是很多本书，每本书的前后句子是有关联关系的；而维基百科的文章的前后句子也是有关系的。对于这个任务，<strong>BERT会以50%的概率抽取有关联的句子(注意这里的句子实际只是联系的Token序列，不是语言学意义上的句子)，另外以50%的概率随机抽取两个无关的句子，然后让BERT模型来判断这两个句子是否相关</strong>。比如下面的两个相关的句子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CLS] the man went to [MASK] store [SEP] he bought a gallon [MASK] milk [SEP]</span><br></pre></td></tr></tbody></table></figure>
<p>下面是两个不相关的句子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CLS] the man [MASK] to the store [SEP] penguin [MASK] are flight ##less birds [SEP]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="fine-tuning">Fine-Tuning</h3>
<p>BERT的Fine-Tuning如下图所示，共分为4类任务。</p>
<p><img src="E:\myBlog\source_posts\bert-3.png" alt="img"> <em>图：BERT的Fine-Tuning</em></p>
<p>对于普通的分类任务，输入是一个序列，如图中右上所示，<strong>所有的Token都是属于同一个Segment(Id=0)，我们用第一个特殊Token [CLS]的最后一层输出接上softmax进行分类，用分类的数据来进行Fine-Tuning</strong>。</p>
<p>对于相似度计算等输入为两个序列的任务，过程如图左上所示。两个序列的Token对应不同的Segment(Id=0/1)。我们也是用第一个特殊Token [CLS]的最后一层输出接上softmax进行分类，然后用分类数据进行Fine-Tuning。</p>
<p>第三类任务是<strong>序列标注，比如命名实体识别</strong>，输入是一个句子(Token序列)，<strong>除了[CLS]和[SEP]的每个时刻都会有输出的Tag</strong>，比如B-PER表示人名的开始，本章的序列标注部分已经介绍过怎么把NER变成序列标注的问题了，这里不再赘述。然后用输出的Tag来进行Fine-Tuning，过程如图右下所示。</p>
<p>第四类是问答类问题，比如SQuAD v1.1数据集，<strong>输入是一个问题和一段很长的包含答案的文字(Paragraph)，输出在这段文字里找到问题的答案。</strong></p>
<p>比如输入的问题是：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Where do water droplets collide with ice crystals to form precipitation?</span><br></pre></td></tr></tbody></table></figure>
<p>包含答案的文字是：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... Precipitation forms as smaller droplets coalesce via collision with other rain drops or ice crystals within a cloud. ...</span><br></pre></td></tr></tbody></table></figure>
<p>正确答案是”within a cloud”。</p>
<p>我们怎么用BERT处理这样的问题呢？我们首先把问题和Paragraph表示成一个长的序列，中间用[SEP]分开，问题对应一个Segment(id=0)，包含答案的文字对于另一个Segment(id=1)。这里有一个假设，那就是答案是Paragraph里的一段<strong>连续的文字(Span)</strong>。BERT把寻找答案的问题转化成寻找这个Span的开始下标和结束下标的问题。</p>
<p>如<a href="http://fancyerii.github.io/2019/03/09/bert-theory/#bert-3" target="_blank" rel="noopener">上图</a>的左下所示。对于Paragraph的第i个Token，BERT的最后一层把它编码成TiTi，然后我们用一个向量S(这是模型的参数，需要根据训练数据调整)和它相乘(内积)计算它是开始位置的得分，因为Paragraph的每一个Token(当然WordPiece的中间，比如##ing是不可能是开始的)都有可能是开始可能，我们用softmax把它变成概率，然后选择概率最大的作为答案的开始：</p>
<p><span class="math inline">\(P_{i}=\frac{e^{S \cdot T_{i}}}{\sum_{j} e^{S \cdot T_{j}}}\)</span></p>
<p>类似的有一个向量T，用于计算答案结束的位置。</p>
<p>论文中作者提到了另外的两个模型，分别是OpenAI GPT和ELMo。</p>
<p>图3展示了这3个模型架构的对比：</p>
<p><img src="E:\myBlog\source_posts\image-20201026200944962.png" alt="image-20201026200944962"></p>
<ul>
<li>BERT使用了双向的Transformer架构，预训练阶段使用了MLM和NSP。</li>
<li>OpenAI GPT使用了left-to-right的Transformer。</li>
<li>ELMo分别使用了left-to-right和right-to-left进行独立训练，然后将输出拼接起来，为下游任务提供序列特征。</li>
</ul>
<p>上面的三个模型架构中，只有BERT模型的表征在每一层都联合考虑到了左边和右边的上下文信息。另外，除了架构不同，还要说明的一点是：BERT和OpenAI GPT是基于fine-tuning的方法，而ELMo是基于feature-based的方法。</p>
<hr>
<h4 id="bert是一套完整的nlp解决方案">2.2. BERT是一套完整的NLP解决方案</h4>
<p><strong>BERT实际上是一套完整的NLP解决方案，是从训练数据集构建到针对具体任务微调的方法、模型综合体</strong>。它的主要内容包括：（1）基于Transformer的模型结构；（2）预训练；（3）微调；（4）推断。其中推断阶段和朴素贝叶斯之类的模型区别不大，这里不做介绍。</p>
<h4 id="bert的总体结构">2.3. BERT的总体结构</h4>
<p>如图2-1，是Devlin等人在论文中给出的BERT结构示意图。BERT的输入是token序列对应的嵌入向量序列。在生命周期的不同阶段，输出是不同的：</p>
<p>在<strong>预训练阶段</strong>，BERT采用<strong>多任务策略</strong>，输出包括“下一个词语”和“是否为下一句”。</p>
<p>在<strong>微调和推断阶段</strong>，BERT(针对<strong>具体的任务</strong>)输出NER标签、答案位置等等。</p>
<p>这个示意图非常概括，BERT内部细节比较模糊。后面进行更详细的介绍。</p>
<p><img src="E:\myBlog\source_posts\v2-0a6e600043f5fac827034bbd97c17e3b_720w.jpg" alt="img"></p>
<p>图 2-1 《BERT》中提供的BERT结构原图</p>
<h4 id="bert的基石transformer">2.4. BERT的基石——Transformer</h4>
<p>图2-1中隐去了BERT内部的结构，即Transformers。</p>
<blockquote>
<p>BERT与GPT在使用Transformer时最大的不同在于，前者使用了Transformer的encoder部分，而后者使用了Transformer的decoder部分。</p>
</blockquote>
<p>GPT认为时间循环结构有助于模型更好地刻画类似文本这样的序列数据；而BERT认为，GPT是一个“单向模型”，没有充分发挥Transformer的特征提取能力。</p>
<p>BERT使用Transformer的encoder部分，即放弃了时间循环结构，完全依赖位置编码来辅助模型刻画序列数据中的时空关联信息。</p>
<p>失之东隅收之桑榆，BERT放弃了时间循环结构，也因此获得了一个机会：<strong>它可以同时处理整个输入序列，而不需要想GPT那样“扫描”。这样的结果就是，相对于GPT，BERT的并行化程度更高、计算速度更快。</strong></p>
<p><img src="E:\myBlog\source_posts\v2-baccec0f601c4f84d5b133070cd23925_720w.jpg" alt="img">图 2-2 Transformer的结构</p>
<h4 id="bert的预训练">2.5. BERT的预训练</h4>
<p>在预训练中，BERT需要同时完成两个任务：（1）随机遮蔽词语预测（MLM masked language model）；（2）“是否下一句”二分类。（NSP）</p>
<h4 id="随机遮蔽词语预测bert是双向语言模型">2.5.1. 随机遮蔽词语预测——BERT是双向语言模型</h4>
<p>在RNN时代，我们会用Bi-RNN或Bi-LSTM来“同时从左到右、从右到左扫描序列数据”。Bi-RNN是一种双向语言模型，刻画了正反两个方向上，序列数据中的时空依赖信息。<strong>双向语言模型，相比RNN等单向模型，可以提取更多的信息，模型潜力也更大。</strong></p>
<p><strong>Transformer也可以用来构建双向语言模型。最粗暴的方式，就是Bi-Transformer，即让2个Transformer分别从左到右和从右到左扫描输入序列。当然，这样做的话，模型参数太多，训练和推断阶段耗时会比较大。</strong></p>
<p>BERT没有在Transformer的结构上费工夫，而是<strong>采用特别的训练策略，迫使模型像双向模型一样思考</strong>。这种训练策略就是<strong>随机遮蔽词语预测</strong>，其流程如图2-3。</p>
<p>BERT会对一个句子的token序列的一部分(15%)进行处理：（1）以80%的概率遮蔽掉(MASK)；（2）以10%的概率替换为其他任意一个token；（3）以10%的概率保持不变。</p>
<p>“遮蔽”是怎么操作的呢？设定一个<strong>专门的token叫做”[MASK]”</strong>，将目标token替换为“[MASK]”即可。</p>
<p><img src="E:\myBlog\source_posts\v2-ee790ee9c9843cf405c5a86f874095d0_720w.jpg" alt="img">图 2-3 BERT的随机遮蔽预处理流程</p>
<p>然后，<strong>BERT会基于未被遮蔽的一部分(剩下85%)预测被遮蔽的tokens</strong>。</p>
<p>假设输入的token序列是“[start]我是中国人。[end]”，经过随机遮蔽处理成为” [start]我[MASK]中[MASK]人。[end]”，那么<strong>BERT就需要输出”是国”这个token序列</strong>。这就决定了，BERT使用了被遮蔽token左右两边的输入序列片段，即所谓“双向”。这个建模方式，有点类似word2vec模型。</p>
<blockquote>
<p>注意，输出是被遮蔽的token序列。</p>
</blockquote>
<h4 id="是否下一句二分类">2.5.2. “是否下一句”二分类</h4>
<p>为了让模型具有理解句子关系，以更好地支持文本匹配这样的下游任务，<strong>BERT在与训练时，还要完成一个二分类任务，即判断句子B是否为句子A的下一句。</strong></p>
<p>这个<strong>任务可以逼迫BERT学习如何输出更好地句子表示。</strong></p>
<h4 id="微调">2.6. 微调</h4>
<p>微调比较简单：添加符合任务要求的输出层，然后基于标注数据训练整个BERT。</p>
<h4 id="结语">3. 结语</h4>
<p>从GPT和BERT出现开始，NLP领域进入了“大力出奇迹”时代。在这个时代里，大数据、大规模参数是构建一个好模型的基础——这还需要大量的计算资源。</p>
<p>土豪们在NLP领域的装备优势越来越大了。不过也不用气馁，我们无需投入几百个GPU去跑一个不知道好不好使的结构，因为机器学习领域已经逐渐形成一种生态：<strong>高水平机构负责创造和训练基准模型，广大普通从业者基于基准模型做进一步的工作。</strong> <strong>预训练 + 微调</strong></p>
<p>疑问： BERT内部详细结构 ： 是如何进行的？</p>
<hr>
<h2 id="前言">前言</h2>
<p>BERT（<strong>B</strong>idirectional <strong>E</strong>ncoder <strong>R</strong>epresentations from <strong>T</strong>ransformers）近期提出之后，作为一个Word2Vec的替代者，其在NLP领域的11个方向大幅刷新了精度，可以说是近年来自残差网络最优突破性的一项技术了。论文的主要特点以下几点：</p>
<ol type="1">
<li>使用了Transformer [2]作为算法的主要框架，Transformer能更彻底的捕捉语句中的双向关系；</li>
<li>使用了Mask Language Model(MLM) [3] 和 Next Sentence Prediction(NSP) 的多任务训练目标；</li>
<li>使用更强大的机器训练更大规模的数据，使BERT的结果达到了全新的高度，并且Google开源了BERT模型，用户可以直接使用BERT作为Word2Vec的转换矩阵并高效的将其应用到自己的任务中。</li>
</ol>
<p>BERT的本质上是通过在海量的语料的基础上运行自监督学习方法为单词学习一个好的特征表示，所谓自监督学习是指在没有人工标注的数据上运行的监督学习。在以后特定的NLP任务中，我们可以直接使用BERT的特征表示作为该任务的词嵌入特征。所以BERT提供的是一个供其它任务迁移学习的模型，该模型可以根据任务微调或者固定之后作为特征提取器。BERT的源码和模型10月31号已经在Github上<a href="https://link.zhihu.com/?target=https%3A//github.com/google-research/bert">开源</a>，简体中文和多语言模型也于11月3号开源。</p>
<h4 id="网络架构">1.1 网络架构</h4>
<p>BERT的网络架构使用的是《Attention is all you need》中提出的多层Transformer结构，其最大的特点是抛弃了传统的RNN和CNN，通过Attention机制将任意位置的两个单词的距离转换成1，有效的解决了NLP中棘手的长期依赖问题。Transformer的结构在NLP领域中已经得到了广泛应用，并且作者已经发布在TensorFlow的<a href="https://link.zhihu.com/?target=https%3A//github.com/tensorflow/tensor2tensor">tensor2tensor</a>库中。</p>
<p>Transformer的网络架构如图1所示，Transformer是一个encoder-decoder的结构，由若干个编码器和解码器堆叠形成。图1的左侧部分为编码器，由Multi-Head Attention和一个全连接组成，用于将输入语料转化成特征向量。右侧部分是解码器，其输入为编码器的输出以及已经预测的结果，由Masked Multi-Head Attention, Multi-Head Attention以及一个全连接组成，用于输出最后结果的条件概率。关于Transformer的详细解析参考我之前总结的<a href="https://zhuanlan.zhihu.com/p/48508221" target="_blank" rel="noopener">文档</a>。</p>
<p><img src="E:\myBlog\source_posts\v2-583765858249a8ebf5c0ececea2cd63c_720w.jpg" alt="img">图1：BERT 中采用的Transformer网络</p>
<p>图1中的左侧部分是一个Transformer Block，对应到图2中的一个“Trm”。</p>
<p><img src="E:\myBlog\source_posts\v2-9979c95d66a71a720207a48311702430_720w.jpg" alt="img">图2：BERT的网络结构</p>
<p>BERT提供了简单和复杂两个模型，对应的超参数分别如下：</p>
<ul>
<li><img src="E:\myBlog\source_posts\equation" alt="[公式]"> : L=12，H=768，A=12，参数总量110M；</li>
<li><img src="E:\myBlog\source_posts\equation" alt="[公式]"> : L=24，H=1024，A=16，参数总量340M；</li>
</ul>
<p>在上面的超参数中，L表示网络的层数（即Transformer blocks的数量），A表示Multi-Head Attention中self-Attention的数量，filter的尺寸是4H。</p>
<p>论文中还对比了BERT和GPT[4]和ELMo[5]，它们两个的结构图如图3所示。</p>
<p><img src="E:\myBlog\source_posts\v2-d36db30f3c68a097f32ed0b49f9845cc_720w.jpg" alt="img">图3：OpenAI GPT和ELMo</p>
<p>BERT对比这两个算法的优点是只有BERT表征会<strong>基于所有层中的左右两侧语境</strong>。BERT能做到这一点得益于Transformer中Attention机制将任意位置的两个单词的距离转换成了1。</p>
<h2 id="输入表示-1">1.2 输入表示</h2>
<p>BERT的输入的编码向量（长度是512）是3个嵌入特征的单位和，如图4，这三个词嵌入特征是：</p>
<ol type="1">
<li>WordPiece 嵌入[6]：WordPiece是指将单词划分成一组有限的公共子词单元，能在单词的有效性和字符的灵活性之间取得一个折中的平衡。例如图4的示例中‘playing’被拆分成了‘play’和‘ing’；</li>
<li>位置嵌入（Position Embedding）：位置嵌入是指将单词的位置信息编码成特征向量，位置嵌入是向模型中引入单词位置关系的至关重要的一环。位置嵌入的具体内容参考我之前的<a href="https://link.zhihu.com/?target=https%3A//senliuy.gitbooks.io/advanced-deep-learning/content/di-er-zhang-ff1a-xu-lie-mo-xing/attention-is-all-you-need.html">分析</a>；</li>
<li>分割嵌入（Segment Embedding）：用于区分两个句子，例如B是否是A的下文（对话场景，问答场景等）。对于句子对，第一个句子的特征值是0，第二个句子的特征值是1。</li>
</ol>
<p>最后，说明一下图4中的两个特殊符号<code>[CLS]</code>和<code>[SEP]</code>，其中<code>[CLS]</code>表示该特征用于分类模型，对非分类模型，该符合可以省去。<code>[SEP]</code>表示分句符号，用于断开输入语料中的两个句子。</p>
<p><img src="E:\myBlog\source_posts\v2-4f9f62a7776afcdd1e1c99dfa57b965f_720w.jpg" alt="img">图4：BERT的输入特征。特征是token嵌入，位置嵌入和分割嵌入的单位和</p>
<h2 id="预训练任务">1.3 预训练任务</h2>
<p>BERT是一个多任务模型，它的任务是由两个自监督任务组成，即MLM和NSP。</p>
<h2 id="task-1-masked-language-model">1.3.1 Task #1： Masked Language Model</h2>
<p>Masked Language Model（MLM）和核心思想取自Wilson Taylor在1953年发表的一篇论文[7]。所谓MLM是指在训练的时候随即从输入预料上mask掉一些单词，然后通过的上下文预测该单词，该任务非常像我们在中学时期经常做的完形填空。正如传统的语言模型算法和RNN匹配那样，MLM的这个性质和Transformer的结构是非常匹配的。</p>
<p>在BERT的实验中，15%的WordPiece Token会被随机Mask掉。在训练模型时，一个句子会被多次喂到模型中用于参数学习，但是Google并没有在每次都mask掉这些单词，而是在确定要Mask掉的单词之后，80%的时候会直接替换为[Mask]，10%的时候将其替换为其它任意单词，10%的时候会保留原始Token。</p>
<ul>
<li>80%：<code>my dog is hairy -&gt; my dog is [mask]</code></li>
<li>10%：<code>my dog is hairy -&gt; my dog is apple</code></li>
<li>10%：<code>my dog is hairy -&gt; my dog is hairy</code></li>
</ul>
<p>这么做的原因是如果句子中的某个Token100%都会被mask掉，那么在fine-tuning的时候模型就会有一些没有见过的单词。加入随机Token的原因是因为Transformer要保持对每个输入token的分布式表征，否则模型就会记住这个[mask]是token ’hairy‘。至于单词带来的负面影响，因为一个单词被随机替换掉的概率只有15%*10% =1.5%，这个负面影响其实是可以忽略不计的。</p>
<p>另外文章指出每次只预测15%的单词，因此模型收敛的比较慢。</p>
<h2 id="task-2-next-sentence-prediction">1.3.2 Task #2: Next Sentence Prediction</h2>
<p>Next Sentence Prediction（NSP）的任务是判断句子B是否是句子A的下文。如果是的话输出’IsNext‘，否则输出’NotNext‘。训练数据的生成方式是从平行语料中随机抽取的连续两句话，其中50%保留抽取的两句话，它们符合IsNext关系，另外50%的第二句话是随机从预料中提取的，它们的关系是NotNext的。这个关系保存在图4中的<code>[CLS]</code>符号中。</p>
<h2 id="微调-1">1.4 微调</h2>
<p>在海量单预料上训练完BERT之后，便可以将其应用到NLP的各个任务中了。对于NSP任务来说，其条件概率表示为 <img src="E:\myBlog\source_posts\equation" alt="[公式]"> ，其中 <img src="E:\myBlog\source_posts\equation" alt="[公式]"> 是BERT输出中的<code>[CLS]</code>符号， <img src="E:\myBlog\source_posts\equation" alt="[公式]"> 是可学习的权值矩阵。</p>
<p>对于其它任务来说，我们也可以根据BERT的输出信息作出对应的预测。图5展示了BERT在11个不同任务中的模型，它们只需要在BERT的基础上再添加一个输出层便可以完成对特定任务的微调。这些任务类似于我们做过的文科试卷，其中有选择题，简答题等等。图5中其中Tok表示不同的Token， <img src="E:\myBlog\source_posts\equation" alt="[公式]"> 表示嵌入向量， <img src="E:\myBlog\source_posts\equation" alt="[公式]"> 表示第 <img src="E:\myBlog\source_posts\equation" alt="[公式]"> 个Token在经过BERT处理之后得到的特征向量。</p>
<p><img src="E:\myBlog\source_posts\v2-f576d9d19c9dcac1c6ee6ea28ea7a2d9_720w.jpg" alt="img">图5：BERT用于模型微调</p>
<p>微调的任务包括（a）基于句子对的分类任务：</p>
<ul>
<li>MNLI：给定一个前提 (Premise) ，根据这个前提去推断假设 (Hypothesis) 与前提的关系。该任务的关系分为三种，蕴含关系 (Entailment)、矛盾关系 (Contradiction) 以及中立关系 (Neutral)。所以这个问题本质上是一个分类问题，我们需要做的是去发掘前提和假设这两个句子对之间的交互信息。</li>
<li>QQP：基于Quora，判断 Quora 上的两个问题句是否表示的是一样的意思。</li>
<li>QNLI：用于判断文本是否包含问题的答案，类似于我们做阅读理解定位问题所在的段落。</li>
<li>STS-B：预测两个句子的相似性，包括5个级别。</li>
<li>MRPC：也是判断两个句子是否是等价的。</li>
<li>RTE：类似于MNLI，但是只是对蕴含关系的二分类判断，而且数据集更小。</li>
<li>SWAG：从四个句子中选择为可能为前句下文的那个。</li>
</ul>
<p>（b）基于单个句子的分类任务</p>
<ul>
<li>SST-2：电影评价的情感分析。</li>
<li>CoLA：句子语义判断，是否是可接受的（Acceptable）。</li>
</ul>
<p>对于GLUE数据集的分类任务（MNLI，QQP，QNLI，SST-B，MRPC，RTE，SST-2，CoLA），BERT的微调方法是根据<code>[CLS]</code>标志生成一组特征向量 <img src="E:\myBlog\source_posts\equation" alt="[公式]"> ，并通过一层全连接进行微调。损失函数根据任务类型自行设计，例如多分类的softmax或者二分类的sigmoid。</p>
<p>SWAG的微调方法与GLUE数据集类似，只不过其输出是四个<strong>可能选项</strong>的softmax：</p>
<p><img src="E:\myBlog\source_posts\equation" alt="[公式]"></p>
<p>（c）问答任务</p>
<ul>
<li>SQuAD v1.1：给定一个句子（通常是一个问题）和一段描述文本，输出这个问题的答案，类似于做阅读理解的简答题。如图5.(c)表示的，SQuAD的输入是问题和描述文本的句子对。输出是特征向量，通过在<strong>描述文本</strong>上接一层激活函数为softmax的全连接来获得输出文本的条件概率，全连接的输出节点个数是语料中Token的个数。</li>
</ul>
<p><img src="E:\myBlog\source_posts\equation" alt="[公式]"></p>
<p>（d）命名实体识别</p>
<ul>
<li>CoNLL-2003 NER：判断一个句子中的单词是不是Person，Organization，Location，Miscellaneous或者other（无命名实体）。微调CoNLL-2003 NER时将整个句子作为输入，在每个时间片输出一个概率，并通过softmax得到这个Token的实体类别。</li>
</ul>
<h4 id="总结">2. 总结</h4>
<p>BERT近期火得一塌糊涂不是没有原因的：</p>
<ol type="1">
<li>使用Transformer的结构将已经走向瓶颈期的Word2Vec带向了一个新的方向，并再一次炒火了《Attention is All you Need》这篇论文；</li>
<li>11个NLP任务的精度大幅提升足以震惊整个深度学习领域；</li>
<li>无私的开源了多种语言的源码和模型，具有非常高的商业价值。</li>
<li>迁移学习又一次胜利，而且这次是在NLP领域的大胜，狂胜。</li>
</ol>
<p>BERT算法还有很大的优化空间，例如我们在Transformer中讲的如何让模型有捕捉Token序列关系的能力，而不是简单依靠位置嵌入。BERT的训练在目前的计算资源下很难完成，论文中说 <img src="E:\myBlog\source_posts\equation" alt="[]"> 的训练需要在64块TPU芯片上训练4天完成，而一块TPU的速度约是目前主流GPU的7-8倍。非常幸运的是谷歌开源了各种语言的模型，免去了我们自己训练的工作。</p>
<hr>
<p>[CLS]就是classification的意思，可以理解为用于下游的分类任务。</p>
<p>主要用于以下两种任务：</p>
<ul>
<li>单文本分类任务：对于文本分类任务，BERT模型在文本前插入一个[CLS]符号，并将该符号对应的输出向量作为整篇文本的语义表示，用于文本分类，如下图所示。可以理解为：<strong>与文本中已有的其它字/词相比，这个无明显语义信息的符号会更“公平”地融合文本中各个字/词的语义信息。</strong></li>
</ul>
<p><img src="E:\myBlog\source_posts\20191019174056699.png" alt="img"></p>
<ul>
<li>语句对分类任务：该任务的实际应用场景包括：问答（判断一个问题与一个答案是否匹配）、语句匹配（两句话是否表达同一个意思）等。<strong>对于该任务，BERT模型除了添加[CLS]符号并将对应的输出作为文本的语义表示，还对输入的两句话用一个[SEP]符号作分割，并分别对两句话附加两个不同的文本向量以作区分</strong>，如下图所示。</li>
</ul>
<p><img src="E:\myBlog\source_posts\20191019174247812.png" alt="img"></p>
<hr>
<h3 id="模型架构">模型架构</h3>
<h4 id="输入表示-2">输入表示</h4>
<ul>
<li><p>我们的输入表示能够在一个标记序列中明确地表示单个文本句子或一对文本句子（例如，[问题，答案]）。一个词的输入=词的embeding+段embeding+位置embeding</p>
<p><img src="E:\myBlog\source_posts\20190418105905367.png" alt="img"></p></li>
<li><p>对于词embeding论文使用<a href="https://arxiv.org/pdf/1609.08144.pdf" target="_blank" rel="noopener">WordPiece embeddings</a></p></li>
<li><p>每个序列的第一个字符始终是特殊分类embedding([CLS])。对应于该字符的最终隐藏状态（即，Transformer的输出）被视为<strong>整个序列表示</strong>常用于聚合用作分类任务。<strong>对于非分类任务，将忽略此向量。</strong></p></li>
</ul>
<h4 id="预训练">预训练</h4>
<ul>
<li>任务一：Masked LM
<ul>
<li>标准条件语言模型只能从左到右或从右到左进行训练，因为双向条件语言模型将允许每个单词在多层self-attention中间接看到自己。<strong>为了避免当前要预测的词在self-attention中看到要预测的答案我们采样的方法是：随机屏蔽掉(mask)输入序列中一定比例的输入词，然后仅预测那些被屏蔽的词,称这个方法叫masked LM(MLM)，最后我们将这个被mask的词的最后隐藏层输出，输入到softmax层中预测这个被mask的词</strong></li>
<li>在论文的实验中我们<strong>每次mask掉一个序列的15%词</strong></li>
<li>该任务的两个缺点：
<ul>
<li>第一个：这种操作使得预训练和微调之间不匹配，因为在微调期间可能没有[MASK]字符。为了缓解这种情况我们不总是用[MASK]词来替换被mask掉的词，而是80%的用[MASK]词来替换被mask掉的词，10%用一个随机词来替换被mask掉的词，再，10%保存源词不变。例子：
<ul>
<li>原句：my dog is hairy 我们要mask掉hairy</li>
<li>80%：my dog is [MASK]</li>
<li>10%：my dog is apple</li>
<li>10%：my dog is hairy</li>
</ul></li>
<li>第二个：<strong>每个batch中只预测了15％的词，这表明模型可能需要更多的预训练步骤才能收敛。实验证明该任务的训练略微慢一点比起预测每一个词的语言模型。</strong></li>
</ul></li>
</ul></li>
<li>任务二：Next Sentence Prediction
<ul>
<li>为了训练理解句子关系的模型，我们预先训练下一句话预测任务，该任务可以从任何单语言语料库中生成。具体地，在构建每个预训练样本时，选择句子A和B，50％B是A的实际下一句子， 50％B是来自语料库的一个随机句子，例子如下：
<ul>
<li><strong>Input</strong> = [CLS] the man went to [MASK] store [SEP] he bought a gallon [MASK] milk [SEP]</li>
<li><strong>Label</strong> = IsNext</li>
<li><strong>Input</strong> = [CLS] the man [MASK] to the store [SEP] penguin [MASK] are flight ##less birds [SEP]</li>
<li><strong>Label</strong> = NotNext</li>
</ul></li>
</ul></li>
<li>预训练过程设置：
<ul>
<li>输入序列长度为512，batch_size=256,训练1000000步近似在33亿词的预料库上40 epochs</li>
<li>使用Adam优化器，learning_rate=1e-4, β_1= 0.9, β_2= 0.999,权重的L2正则项系数为0.01，学习率是预热步数：10000，学习率线性衰退，在每一层使用概率为0.1的dropout，激活函数使用<a href="https://arxiv.org/abs/1606.08415" target="_blank" rel="noopener">gelu</a></li>
</ul></li>
</ul>
<h3 id="微调-2">微调</h3>
<ul>
<li><p>对于序列水平的分类任务，我们<strong>获取第一个词[CLS]的最后隐藏层状态,再将C经过一个全连接层得到最后的预测分布，其中K是类别数。</strong>W也是这种特殊任务唯一添加的模型参数。</p></li>
<li><p>在微调的过程中BERT和W被同时微调。</p></li>
<li><p><strong>在微调中，大多数模型超参数与预训练相同，一般修改的超参数是：batch_size, learning_rate, epochs。 Dropout的概率始终保持在0.1</strong>。理论上说最佳超参数值随特定于任务不同而不同，但我们发现以下范围的可能值可以在所有任务中很好地工作：</p>
<ul>
<li>Batch size: 16, 32</li>
<li>Learning rate (Adam): 5e-5, 3e-5, 2e-5</li>
<li>Number of epochs: 3, 4</li>
</ul></li>
<li><p>我们还观察到，大数据集对超参数选择的敏感性远小于小数据集</p></li>
<li><p>微调总结图：</p>
<p><img src="E:\myBlog\source_posts\20190418111747424.png" alt="img"></p>
<p>图一：预测两个句子的关系，图二：是对当个句子分类。</p></li>
</ul>
<h2 id="模型对比">模型对比</h2>
<p><img src="E:\myBlog\source_posts\2019041811190075.png" alt="img"></p>
<h1 id="总结-1">总结</h1>
<h2 id="词嵌入语言模型的方法">词嵌入语言模型的方法</h2>
<ul>
<li><p>NLP词嵌入语言模型的方法：</p>
<ul>
<li><p>Feature-based方法</p>
<ul>
<li><p>Feature-based指利用预先训练好的语言模型的结果,作为当前特定任务模型（task-specific）的一个额外的特征引入到当前特定任务模型中，例如下图的语言模型</p>
<p><img src="E:\myBlog\source_posts\20190418112208513.png" alt="img"></p>
<p>上图中，左边部分为序列标注模型，也就是task-specific model，每个任务可能不同，右边是两个预训练好的前向LM(Left-to-right)和后向LM(Right-To-Left), 将两个LM的结果进行了合并，并将LM embedding与词向量、第一层RNN输出、第二层RNN输出进行了concat操作</p></li>
<li><p>通常feature-based方法包括两步：</p>
<ul>
<li>首先在大的语料A上无监督地训练语言模型，训练完毕得到语言模型。</li>
<li>然后构造task-specific model例如序列标注模型，采用有label的语料B来有监地训练task-sepcific model，将语言模型的参数固定，语料B的训练数据经过语言模型得到LM embedding，作为task-specific model的额外特征</li>
</ul></li>
<li><p>ELMo是这方面的典型代表</p></li>
</ul></li>
</ul></li>
<li><p>Fine-tuning方法</p>
<ul>
<li><p>Fine-tuning方式是指在已经训练好的语言模型的基础上，加入少量的task-specific parameters, 例如对于分类问题在语言模型基础上加一层softmax网络，然后在新的语料上重新训练来进行fine-tune。</p></li>
<li><p>OpenAI GPT 是这一方法的典型代表，其模型如下所示:</p>
<p><img src="E:\myBlog\source_posts\20190418112554368.png" alt="img"></p>
<p>GPT首先语言模型采用了Transformer Decoder的方法来进行训练，采用文本预测作为语言模型训练任务，训练完毕之后，加一层Linear Project来完成分类/相似度计算等NLP任务。</p></li>
<li><p>Fine-Tuning的方法工作包括两步：</p>
<ul>
<li>构造语言模型，采用大的语料A来训练语言模型</li>
<li>在语言模型基础上增加少量神经网络层来完成specific task model例如序列标注、分类等，然后采用有label的语料B来有监督地训练模型，这个过程中语言模型的参数并不固定.</li>
</ul></li>
<li><p>而BERT采用了fine-tuning的方法，并且在许多task-specific model中取得了最好的效果</p></li>
</ul></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fab fa-gratipay"></i>感谢阅读-------------</div>
        <div class="reward-container">
  <div>卑微博主，在线求赏</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="李思建 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

    
      
   
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/22/2020-10-22-MAML%E8%AE%BA%E6%96%87/" rel="prev" title="2020-10-22-MAML论文">
      <i class="fa fa-chevron-left"></i> 2020-10-22-MAML论文
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/28/2020-10-28-transformer%E7%BB%BC%E8%BF%B0/" rel="next" title="2020-10-28-transformer综述">
      2020-10-28-transformer综述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  





          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入表示"><span class="nav-number">1.</span> <span class="nav-text">输入表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mask-lm"><span class="nav-number">2.</span> <span class="nav-text">Mask LM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预测句子关系"><span class="nav-number">3.</span> <span class="nav-text">预测句子关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fine-tuning"><span class="nav-number">4.</span> <span class="nav-text">Fine-Tuning</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bert是一套完整的nlp解决方案"><span class="nav-number">4.1.</span> <span class="nav-text">2.2. BERT是一套完整的NLP解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bert的总体结构"><span class="nav-number">4.2.</span> <span class="nav-text">2.3. BERT的总体结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bert的基石transformer"><span class="nav-number">4.3.</span> <span class="nav-text">2.4. BERT的基石——Transformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bert的预训练"><span class="nav-number">4.4.</span> <span class="nav-text">2.5. BERT的预训练</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机遮蔽词语预测bert是双向语言模型"><span class="nav-number">4.5.</span> <span class="nav-text">2.5.1. 随机遮蔽词语预测——BERT是双向语言模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#是否下一句二分类"><span class="nav-number">4.6.</span> <span class="nav-text">2.5.2. “是否下一句”二分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微调"><span class="nav-number">4.7.</span> <span class="nav-text">2.6. 微调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结语"><span class="nav-number">4.8.</span> <span class="nav-text">3. 结语</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number"></span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络架构"><span class="nav-number">0.1.</span> <span class="nav-text">1.1 网络架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入表示-1"><span class="nav-number"></span> <span class="nav-text">1.2 输入表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预训练任务"><span class="nav-number"></span> <span class="nav-text">1.3 预训练任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-1-masked-language-model"><span class="nav-number"></span> <span class="nav-text">1.3.1 Task #1： Masked Language Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-2-next-sentence-prediction"><span class="nav-number"></span> <span class="nav-text">1.3.2 Task #2: Next Sentence Prediction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微调-1"><span class="nav-number"></span> <span class="nav-text">1.4 微调</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">0.1.</span> <span class="nav-text">2. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型架构"><span class="nav-number">1.</span> <span class="nav-text">模型架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入表示-2"><span class="nav-number">1.1.</span> <span class="nav-text">输入表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预训练"><span class="nav-number">1.2.</span> <span class="nav-text">预训练</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微调-2"><span class="nav-number">2.</span> <span class="nav-text">微调</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型对比"><span class="nav-number"></span> <span class="nav-text">模型对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结-1"><span class="nav-number"></span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#词嵌入语言模型的方法"><span class="nav-number"></span> <span class="nav-text">词嵌入语言模型的方法</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李思建"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">李思建</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    <a onclick="tidioChatApi.open();"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/OopsAaron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;OopsAaron" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:li1574468139@outlook.com" title="E-Mail → mailto:li1574468139@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5871697996" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5871697996" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/AaronLe48891280" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;AaronLe48891280" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ife.baidu.com/" title="http:&#x2F;&#x2F;ife.baidu.com&#x2F;" rel="noopener" target="_blank">百度前端技术学院</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wf.uisdc.com/cn/" title="http:&#x2F;&#x2F;wf.uisdc.com&#x2F;cn&#x2F;" rel="noopener" target="_blank">google前端开发基础</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>

 


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fas fa-atom"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李思建</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">356k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>
  
        
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>



  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/6hx5cq5nmltu08pt7pfkqy85wvgnhr1r.js"></script>







    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'V06xtKF2qonsMYpPA6OqiRH0-gzGzoHsz',
      appKey     : 'Q8gXivQlmWVnr48ahETG2v5X',
      placeholder: "Just go go",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
  


</body>


</html>
